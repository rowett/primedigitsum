#! /bin/bash
# monitor progress
# Usage: monitor [-c columns] [-d directory] [-w] [interval]
#   -c        number of columns
#   -d	      directory to monitor
#   -w        only display work in progress
#   interval  refresh every interval seconds
#
# displays a table of the highest number of primes for each block
# followed by the status of any blocks currently being processed
#
# if a refresh interval is supplied then the table width and
# height are dynamicly sized based on the terminal and colour
# will be used for the output

# set default tab width
tab_width=8

# set program name and command usage
prog_name=`basename $0`
usage="$prog_name [-c number] [-d directory] [-w] [interval]\n  -c\t\tnumber of columns\n  -d\t\tdirectory\n  -w\t\tonly display work in progress\n  interval\trefresh every interval seconds"

# trap terminal resize events
trap 'terminal_resize' SIGWINCH
trap 'process_exit' SIGINT

# reset terminal
reset_terminal() {
	if [[ $tab_width != 8 ]]
	then
		tabs -8
		tab_width=8
	fi
}

# function to reset terminal before exit
process_exit() {
	reset_terminal
	exit 0
}

# function to flag width update when terminal is resized
terminal_resize() {
	# flag setup needed
	setup_needed=1
}

# setup output for terminal size
setup_output() {
	# get the width of the terminal
	term_width=`tput cols`
	term_height=`tput lines`

	# check if refreshing
	if [[ $refresh_interval != 0 ]]
	then
		# set narrower tabs
		tabs -$tab_width
	fi

	# check if column supplied on the command line
	if [[ $num_cmdline == 0 ]]
	then
		# divide the terminal width into tab columns
		num_cols=$((term_width/tab_width))
		num_cols=$((num_cols-2))
	fi

	# build the argument for the paste command based on tab widths
	paste_arg=$(printf "%-${num_cols}s" "-" | sed "s/ / -/g")

	# build the header
	header="${s_blue}Block"
	b=0
	for l in ${paste_arg}
	do
		header="${header}\t+${b}"
		b=$((b+1))
	done
}

# report error and exit
error_exit() {
	s_red=`tput setaf 1`
	s_standard=`tput setaf 7`
	reset_terminal
	echo -e "${s_red}${prog_name}: $1${s_standard}\n$usage"
	exit 1
}

# check command line for work in progress only flag
re='^[0-9]+$'
directory=blocks
wip_only=0
refresh_interval=0
num_cols=0
num_cmdline=0

# check for valid options
while getopts ":c:d:w" opt
do
	case "$opt" in
	# number of columns
	c)	num_cols=$OPTARG
		num_cmdline=1
		# check it is a number
		if ! [[ $num_cols =~ $re ]]
		then
			error_exit "columns must be a number"
		else
			# check it is in range
			if [[ $num_cols -lt 1 ]]
			then
				error_exit "columns must be positive"
			fi
		fi
		;;
	# blocks directory
	d)	directory=$OPTARG
		# check it is a directory
		if [[ ! -d "$directory" ]]
		then
			error_exit "$directory: no such directory"
		fi
		;;
	# work in progress only
	w)	wip_only=1
		;;
	# other flags are invalid
	\?)	error_exit "invalid argument $OPTARG"
	esac
done
shift $((OPTIND-1))

# check for interval
if [[ "$1" != "" ]]
then
	# read the refresh interval
	refresh_interval=$1

	# check it is a number
	if ! [[ $refresh_interval =~ $re ]]
	then
		error_exit "interval must be a number"
	else
		# check it is in range
		if [[ $refresh_interval -lt 1 ]]
		then
			error_exit "interval must be positive"
		fi
	fi
fi

# define colour output for echo and sed commands
if [[ $refresh_interval -gt 0 ]]
then
	s_blue=`tput setaf 4`
	s_red=`tput setaf 1`
	s_yellow=`tput setaf 3`
	s_green=`tput setaf 2`
	s_cyan=`tput setaf 6`
	s_magenta=`tput setaf 5`
	s_standard=`tput setaf 7`
else
	s_blue=""
	s_red=""
	s_yellow=""
	s_green=""
        s_cyan=""
        s_magenta=""
	s_standard=""
fi

# change to the blocks directory
if [[ ! -d $directory ]]
then
	error_exit "$directory: no such directory"
fi
cd $directory

# set required tab width
if [[ $refresh_interval -gt 0 ]]
then
	# set tab width
	tab_width=4
fi

# flag that output setup needed
setup_needed=1

# repeat forever
while [[ true ]]
do
	# check if output setup needed
	if [[ $setup_needed == 1 ]]
	then
		# setup output
		setup_output

		# flag setup done
		setup_needed=0
	fi

	# set the number of lines available taking into account headers
	lines=$((term_height-6))

	# check if there are any work in progress blocks
	wip_list=""
	if [[ `echo *.tmp` != "*.tmp" ]]
	then
		# get a sorted list of work in progress blocks
		wip_list=`echo *.tmp | tr " " "\n" | sort -n | tr "\n" " "`

		# find out how many work in progress blocks there are
		wip_count=`echo $wip_list | wc -w`
	
		# subtract wip lines from available lines since we display five per line
		lines=$((lines-((wip_count+1)/5)))
	fi

	# check if only work in progress needed
	if [[ $wip_only == 0 ]]
	then
		# check if there are any results
		if [[ `echo *.txt` != "*.txt" ]]
		then
			# check for refresh only
			if [[ $refresh_interval == 0 ]]
			then
				lines=1000000
			fi

			# create a sorted list of result files
			file_list=`echo *.txt | tr " " "\n" | sort -n | tr "\n" " "`
			output=$header@`grep "No" $file_list | sed "s/No matches [a-z]* //;s/.txt//;s/ primes//" | paste -d " " $paste_arg | sed "s/ [1-9][0-9]*//g;s/:/\t/g;s/\([0-9][0-9]*\)/${s_blue}\1/;s/\t1[0-9]/${s_red}&/g;s/\t2[0-4]/${s_yellow}&/g;s/\t2[5-9]/${s_green}&/g;s/\t3[0-9]/${s_cyan}&/g;s/\t--/${s_magenta}&/g" | tail -n ${lines} | tr "\n\t" "@#"`
		else
			output="${s_red}No completed blocks found${s_standard}"
		fi

		# clear the display
		if [[ $refresh_interval -gt 0 ]]
		then
			clear
		fi

		# display completed blocks in a table
		echo -e $output | tr "@#" "\n\t"
	else
		# work in progress only so clear the display
		if [[ $refresh_interval -gt 0 ]]
		then
			clear
		fi
	fi

	# display work in progress if present
	if [[ "$wip_list" != "" ]]
	then
		# display work in progress header
		echo -e "${s_blue}\tWork in progress${s_standard}"

                contents=""
                n=0
                for block in $wip_list
                do
                        content=`tail -n 1 $block | sed "s/\([1-9][0-9]*\).*/\1/"`
                        number=`echo $block | sed "s/.tmp//"`
                        if [[ "$content" == "" ]]
                        then
                                contents="$contents\t$s_blue$number:$s_magenta--$s_standard"
                        else
                                contents="$contents\t$s_blue$number$s_standard:$content"
                        fi
                        n=$((n+1))
                        if [[ $n -eq 5 ]]
                        then
                            n=0
                            contents="$contents\n"
                        fi
                done
                echo -e $contents | sed "s/:1[0-9]/${s_red}&${s_standard}/g;s/:2[0-4]/${s_yellow}&${s_standard}/g;s/:2[5-9]/${s_green}&${s_standard}/g;s/:3[0-9]/${s_cyan}&${s_standard}/g;s/:/\t/g"
	else
		echo -e "${s_red}No work in progress blocks found${s_standard}"
	fi

	# check for display once
	if [[ $refresh_interval == 0 ]]
	then
		exit 0
	fi

	# pause for refresh interval seconds
	echo -en "\n${s_blue}Refreshing every $refresh_interval seconds...${s_standard}"
	sleep ${refresh_interval} &
	wait
done
